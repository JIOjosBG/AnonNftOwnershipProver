// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
// use ethers::prelude::*;
// // use ethers::utils::hash_message;
// use ethers::core::utils::hash_message;
// use methods::{ANON_HOLDER_GUEST_ELF, ANON_HOLDER_GUEST_ID};
// use risc0_zkvm::serde::to_vec;
// use risc0_zkvm::{default_prover, ExecutorEnv};

use std::env::{self};
use std::process;

use risc0_zkvm::Receipt;

mod cli_input;
mod nft_utils;
mod termbin_utils;
mod zk_utils;

// @TODO better expain errors here
// @TODO write tests for all utils
// @TODO finish console logs
#[tokio::main]
async fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() != 2 {
        eprintln!("Wrong number of arguments");
        process::exit(1);
    }
    if args[1] != "prover" && args[1] != "verifier" {
        eprintln!(
            "Wrong execution mode, expected prover or verifier, received {}",
            args[1]
        );
        process::exit(1);
    }
    if args[1] == "prover" {
        let (nft_address, signature) = cli_input::prover_inputs().unwrap_or_else(|e| {
            eprintln!("Error: {}", e);
            process::exit(1);
        });
        let nft_owners = nft_utils::fetch_nft_owners(nft_address)
            .await
            .unwrap_or_else(|e| {
                eprintln!("Error: {}", e);
                process::exit(1);
            });
        let receipt: Receipt = zk_utils::generate_proof(nft_address, signature, nft_owners)
            .unwrap_or_else(|e| {
                eprintln!("Error: {}", e);
                process::exit(1);
            });
        let termbin_link = termbin_utils::upload_receipt_to_termbin(&receipt)
            .await
            .unwrap_or_else(|e| {
                eprintln!("Error: {}", e);
                process::exit(1);
            });

        println!("{:?}", termbin_link);
    } else if args[1] == "verifier" {
        let termbin_url = cli_input::get_termbin_url().unwrap_or_else(|e| {
            eprintln!("Error: {}", e);
            process::exit(1);
        });

        let receipt: Receipt = termbin_utils::get_receipt_from_termbin(termbin_url)
            .await
            .unwrap_or_else(|e| {
                eprintln!("Error: {}", e);
                process::exit(1);
            });
        let (nft_owners, nft_address) =
            zk_utils::verify_and_extract_data(&receipt).unwrap_or_else(|e| {
                eprintln!("Error: {}", e);
                process::exit(1);
            });
        let are_all_owners_legit = nft_utils::check_are_all_owners_legit(&nft_owners, nft_address)
            .await
            .unwrap_or_else(|e| {
                eprintln!("Error: {}", e);
                process::exit(1);
            });
        println!("{:?}", are_all_owners_legit);
    }
}
